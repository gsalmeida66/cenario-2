<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Plano de Ação - Retenção</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f7f9fc;
      overflow: hidden;
    }
    ::-webkit-scrollbar {
      display: none;
    }
    body {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
  </style>
</head>
<body>

  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect } = React;

    // Helper function to calculate the number of business days between two dates
    const getBusinessDays = (startDate, endDate) => {
      let count = 0;
      const currentDate = new Date(startDate);
      currentDate.setHours(0, 0, 0, 0);
      const end = new Date(endDate);
      end.setHours(0, 0, 0, 0);

      while (currentDate <= end) {
        const dayOfWeek = currentDate.getDay();
        if (dayOfWeek !== 0 && dayOfWeek !== 6) { // 0 = Sunday, 6 = Saturday
          count++;
        }
        currentDate.setDate(currentDate.getDate() + 1);
      }
      return count;
    };

    // Helper function to add business days to a date
    const addBusinessDays = (date, days) => {
      const result = new Date(date);
      result.setHours(0, 0, 0, 0); // Normalize to start of day
      let addedDays = 0;
      while (addedDays < days) {
        result.setDate(result.getDate() + 1);
        if (result.getDay() !== 0 && result.getDay() !== 6) {
          addedDays++;
        }
      }
      return result;
    };

    // Helper function to format the date for display
    const formatDate = (date) => {
      if (!date) return '';
      const d = new Date(date);
      const options = { month: 'short', day: 'numeric' };
      return d.toLocaleDateString('pt-BR', options);
    };

    const App = () => {
      const timelineStartDateBotSac = new Date('2025-06-09T00:00:00');
      const timelineEndDateHardLimit = new Date('2025-12-18T23:59:59');
      const projectLabelWidth = 120;
      const paddingRight = 50;

      const [calculatedDaysPerPixel, setCalculatedDaysPerPixel] = useState(40);
      const [calculatedTimelineWidth, setCalculatedTimelineWidth] = useState(3000);
      // Novo estado para a posição da linha da data atual
      const [todayLinePosition, setTodayLinePosition] = useState(0);


      // Original project data with tasks, copied from teste.html
      const originalProjectsData = [
        {
          id: 'bot_sac',
          name: '[BOT SAC] Menu ACOA',
          tasks: [
            { id: 'consolidated_bot_sac', name: 'BOT SAC (Menu ACOA)', duration: getBusinessDays(new Date('2025-06-13T00:00:00'), new Date('2025-09-05T00:00:00')), status: 'Em Andamento', predecessors: [], startDate: new Date('2025-06-13T00:00:00') },
          ],
          progress: 100,
        },
        {
          id: 'ura_reservas',
          name: '[URA Reservas] Info Loja + ACOA',
          tasks: [
           { id: 'consolidated_ura_reservas', name: '[URA Reservas] Info Loja + ACOA', duration: 30, status: 'Em Andamento', predecessors: [], startDate: new Date('2025-09-22T00:00:00') },
          ],
          progress: 10,
        },
         {
          id: 'bot_cpa',
          name: '[Bot CPA]',
          tasks: [
            { id: 'consolidated_bot_cpa', name: '[Bot CPA]', duration: 70, status: 'Em Andamento', predecessors: [], startDate: new Date('2025-09-01T00:00:00') },
          ],
          progress: 12,
        },
        {
          id: 'bot_rac',
          name: '[BOT RAC] Assistência 24h + Manutenção',
          tasks: [
            { id: 'consolidated_bot_rac', name: '[BOT RAC] Assistência 24h + Manutenção', duration: 30, status: 'Em Andamento', predecessors: [], startDate: new Date('2025-10-20T00:00:00') },
          ],
          progress: 0,
        },
        {
          id: 'bot_cpa_nova_contratacao',
          name: '[BOT CPA] Nova Contratação + Agendamento',
          tasks: [
            { id: 'consolidated_nova_contratacao', name: 'Nova Contratação + Agendamento', duration: 30, status: 'Não Iniciado', predecessors: [], startDate: new Date('2025-11-08T00:00:00') },
          ],
          progress: 0,
        },
      ];

      // Function to calculate start, end, and status for a project based on its tasks
      const calculateProjectDetails = (projectData, allProjects) => {
        let minStartDate = null;
        let maxEndDate = null;
        let hasInProgress = false;
        let hasNotStarted = false;

        const taskCalculatedDates = {};

        const calculateTaskStartDate = (taskId, currentProjectId, tasksSource) => {
            if (taskCalculatedDates[taskId]) {
                return taskCalculatedDates[taskId];
            }

            const task = tasksSource.find(t => t.id === taskId);
            if (!task) {
                return timelineStartDateBotSac;
            }

            if (task.startDate) {
                const date = new Date(task.startDate);
                date.setHours(0,0,0,0);
                taskCalculatedDates[taskId] = date;
                return date;
            }

            if (task.predecessors && task.predecessors.length > 0) {
                let latestPredecessorEndDate = timelineStartDateBotSac;
                task.predecessors.forEach(predId => {
                    const predIdParts = predId.split(':');
                    const predecessorProjectId = predIdParts.length > 1 ? predIdParts[0] : currentProjectId;
                    const predecessorTaskId = predIdParts.length > 1 ? predIdParts[1] : predIdParts[0];

                    let predTask;
                    let predTasksForCalc = tasksSource;

                    if (predecessorProjectId === currentProjectId) {
                        predTask = tasksSource.find(t => t.id === predecessorTaskId);
                    } else {
                        const otherProject = allProjects.find(p => p.id === predecessorProjectId);
                        if (otherProject) {
                            predTask = otherProject.tasks.find(t => t.id === predecessorTaskId);
                            predTasksForCalc = otherProject.tasks;
                        }
                    }

                    if (predTask) {
                        const predStartDate = calculateTaskStartDate(predTask.id, predecessorProjectId, predTasksForCalc);
                        const predEndDate = addBusinessDays(predStartDate, predTask.duration - 1);
                        if (predEndDate.getTime() > latestPredecessorEndDate.getTime()) {
                            latestPredecessorEndDate = predEndDate;
                        }
                    }
                });
                const startDate = addBusinessDays(latestPredecessorEndDate, 1);
                taskCalculatedDates[taskId] = startDate;
                return startDate;
            } else {
                taskCalculatedDates[taskId] = timelineStartDateBotSac;
                return timelineStartDateBotSac;
            }
        };

        projectData.tasks.forEach(task => calculateTaskStartDate(task.id, projectData.id, projectData.tasks));

        projectData.tasks.forEach(task => {
          const taskStartDate = taskCalculatedDates[task.id];
          const taskEndDate = addBusinessDays(taskStartDate, task.duration - 1);

          if (!minStartDate || taskStartDate.getTime() < minStartDate.getTime()) {
            minStartDate = taskStartDate;
          }
          if (!maxEndDate || taskEndDate.getTime() > maxEndDate.getTime()) {
            maxEndDate = taskEndDate;
          }

          if (task.status === 'Em Andamento') {
            hasInProgress = true;
          }
          if (task.status === 'Não Iniciado') {
            hasNotStarted = true;
          }
        });

        let projectStatus = 'Concluída';
        if (hasInProgress) {
          projectStatus = 'Em Andamento';
        } else if (hasNotStarted) {
          projectStatus = 'Não Iniciado';
        }

        const duration = minStartDate && maxEndDate ? getBusinessDays(minStartDate, maxEndDate) : 0;

        return {
          id: projectData.id,
          name: projectData.name,
          startDate: minStartDate,
          endDate: maxEndDate,
          duration: duration,
          progress: projectData.progress !== undefined ? projectData.progress : 0,
        };
      };

      const [projects, setProjects] = useState([]);
      const [editingProject, setEditingProject] = useState(null);
      const [formState, setFormState] = useState({ progress: 0 });
      const [projectPositions, setProjectPositions] = useState({});

      // Effect to update timeline dimensions based on window size
      useEffect(() => {
        const updateTimelineDimensions = () => {
          const totalBusinessDaysForAxis = getBusinessDays(timelineStartDateBotSac, timelineEndDateHardLimit);
          const availableWidth = window.innerWidth * 0.95;
          const timelineDisplayAreaWidth = availableWidth - projectLabelWidth - paddingRight;

          const minDaysPerPixel = 10;
          let newCalculatedDaysPerPixel = timelineDisplayAreaWidth / totalBusinessDaysForAxis;
          if (newCalculatedDaysPerPixel < minDaysPerPixel) {
              newCalculatedDaysPerPixel = minDaysPerPixel;
          }

          setCalculatedDaysPerPixel(newCalculatedDaysPerPixel);
          setCalculatedTimelineWidth(totalBusinessDaysForAxis * newCalculatedDaysPerPixel);
        };

        window.addEventListener('resize', updateTimelineDimensions);
        updateTimelineDimensions();

        return () => window.removeEventListener('resize', updateTimelineDimensions);
      }, []);

      // Effect to calculate project details (dates) and initialize project state
      useEffect(() => {
        const calculatedProjects = originalProjectsData.map(p => {
          const details = calculateProjectDetails(p, originalProjectsData);
          const existingProject = projects.find(ep => ep.id === p.id);
          return { ...details, progress: existingProject ? existingProject.progress : (p.progress !== undefined ? p.progress : 0) };
        });
        setProjects(calculatedProjects);
      }, [calculatedDaysPerPixel]);

      // Effect to calculate project positions on the timeline and today's line position
      useEffect(() => {
        const positions = {};
        projects.forEach(project => {
          if (project.startDate && project.endDate) {
            const referenceDate = timelineStartDateBotSac;
            const businessDaysFromStart = getBusinessDays(referenceDate, project.startDate);
            const left = (businessDaysFromStart - 1) * calculatedDaysPerPixel;
            const duration = getBusinessDays(project.startDate, project.endDate);
            const width = duration * calculatedDaysPerPixel;
            positions[project.id] = { left, width, startDate: project.startDate, endDate: project.endDate, duration };
          }
        });
        setProjectPositions(positions);

        // Lógica para a linha da data atual
        const today = new Date();
        today.setHours(0, 0, 0, 0);

        // Certifique-se de que a data atual não está antes da data de início da timeline
        if (today >= timelineStartDateBotSac) {
            const businessDaysSinceStart = getBusinessDays(timelineStartDateBotSac, today);
            // A posição é calculada a partir do início da área da timeline
            const position = (businessDaysSinceStart - 1) * calculatedDaysPerPixel;
            setTodayLinePosition(position);
        } else {
            setTodayLinePosition(0); // Se a data atual for antes do início, a linha não aparece ou fica no início
        }

      }, [projects, calculatedDaysPerPixel]);

      // Function to determine project color based on progress
      const getProjectColor = (progress) => {
        const p = Math.max(0, Math.min(100, progress));
        if (p === 100) {
          return 'bg-green-500';
        }
        if (p === 0) {
          return 'bg-gray-400';
        }
        if (p === 50) {
          return 'bg-blue-500';
        }

        if (p < 50) {
          const grayRGB = [156, 163, 175];
          const blueRGB = [59, 130, 246];
          const ratio = p / 50;
          const r = Math.round(grayRGB[0] + (blueRGB[0] - grayRGB[0]) * ratio);
          const g = Math.round(grayRGB[1] + (blueRGB[1] - grayRGB[1]) * ratio);
          const b = Math.round(grayRGB[2] + (blueRGB[2] - grayRGB[2]) * ratio);
          return `bg-[rgb(${r},${g},${b})]`;
        }
        if (p > 50) {
          const blueRGB = [59, 130, 246];
          const greenRGB = [34, 197, 94];
          const ratio = (p - 50) / 50;
          const r = Math.round(blueRGB[0] + (greenRGB[0] - blueRGB[0]) * ratio);
          const g = Math.round(blueRGB[1] + (greenRGB[1] - blueRGB[1]) * ratio);
          const b = Math.round(blueRGB[2] + (greenRGB[2] - blueRGB[2]) * ratio);
          return `bg-[rgb(${r},${g},${b})]`;
        }
      };

      // Handles project editing
      const handleEditProject = (projectId) => {
        const project = projects.find(p => p.id === projectId);
        setEditingProject(project);
        setFormState({
          progress: project.progress,
        });
      };

      // Handles saving project edits
      const handleSaveEdit = (e) => {
        e.preventDefault();
        setProjects(prevProjects =>
          prevProjects.map(project =>
            project.id === editingProject.id
              ? { ...project, progress: parseInt(formState.progress, 10) }
              : project
          )
        );
        setEditingProject(null);
      };

      // Generates dates for the timeline (every Monday) and groups them by month
      const getTimelineMonthsAndDays = () => {
        const months = {};
        let currentDate = new Date(timelineStartDateBotSac);
        currentDate.setHours(0,0,0,0);
        
        while(currentDate <= timelineEndDateHardLimit) {
          const monthKey = `${currentDate.getFullYear()}-${currentDate.getMonth()}`;
          
          if (!months[monthKey]) {
            // Se for o primeiro dia do mês ou o primeiro mês da timeline
            // Calcula o índice do mês (0-based) para determinar par/ímpar
            const currentMonthNumber = currentDate.getMonth(); // 0 = Jan, 1 = Feb, etc.
            const isEvenMonth = (currentMonthNumber % 2 === 0);

            months[monthKey] = {
              name: currentDate.toLocaleString('pt-BR', { month: 'long' }).charAt(0).toUpperCase() + currentDate.toLocaleString('pt-BR', { month: 'long' }).slice(1),
              days: [],
              startPx: (getBusinessDays(timelineStartDateBotSac, currentDate) - 1) * calculatedDaysPerPixel,
              endPx: -1, // Será atualizado enquanto iteramos pelos dias do mês
              isEven: isEvenMonth,
            };
          }

          if (currentDate.getDay() === 1) { // Mark every Monday
            const dayPosition = (getBusinessDays(timelineStartDateBotSac, currentDate) - 1) * calculatedDaysPerPixel;
            months[monthKey].days.push({
              date: new Date(currentDate),
              dayOfMonth: currentDate.getDate(),
              position: dayPosition,
            });
          }
          
          // Atualiza o endPx para o último dia útil do mês
          months[monthKey].endPx = (getBusinessDays(timelineStartDateBotSac, currentDate) - 1) * calculatedDaysPerPixel;

          currentDate.setDate(currentDate.getDate() + 1);
        }
        return Object.values(months);
      };

      const timelineMonths = getTimelineMonthsAndDays();

      return (
        <div className="bg-gray-50 flex items-center justify-center p-8 min-h-screen">
          <div className="bg-white pt-[17px] px-8 pb-8 rounded-2xl shadow-xl w-full">
            {/* Novo contêiner para o título e a legenda */}
            <div className="flex justify-between items-center mb-[29px]"> {/* Ajustado mb-[29px] */}
              <h1 className="text-3xl font-bold text-gray-800" style={{ marginLeft: `${projectLabelWidth}px` }}>Plano de Ação - Retenção</h1>
              
              {/* Color legend */}
              <div className="flex space-x-4">
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full bg-green-500 mr-2"></div>
                  <span className="text-sm text-gray-600">Concluída (100%)</span>
                </div>
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full bg-blue-500 mr-2"></div>
                  <span className="text-sm text-gray-600">Em Andamento (50%)</span>
                </div>
                <div className="flex items-center">
                  <div className="w-4 h-4 rounded-full bg-gray-400 mr-2"></div>
                  <span className="text-sm text-gray-600">Não Iniciado (0%)</span>
                </div>
              </div>
            </div>

            {/* Timeline and projects container */}
            <div className="relative pb-6" style={{ width: `${calculatedTimelineWidth + projectLabelWidth + paddingRight}px` }}>
              {/* Background columns for months */}
              <div className="absolute top-0 bottom-0 left-0 right-0 z-0" style={{ marginLeft: `${projectLabelWidth}px` }}>
                {timelineMonths.map((month, index) => (
                  <div
                    key={`month-bg-${index}`}
                    className={`absolute top-0 bottom-0 ${month.isEven ? 'bg-white' : 'bg-gray-100'}`}
                    style={{
                      left: `${month.startPx}px`,
                      width: `${month.endPx - month.startPx + calculatedDaysPerPixel}px`,
                    }}
                  ></div>
                ))}
              </div>

              {/* X-axis: Months and Days */}
              <div className="flex flex-col mb-4 relative z-10" style={{ marginLeft: `${projectLabelWidth}px`, width: `${calculatedTimelineWidth}px` }}>
                {/* Month Headers */}
                <div className="flex relative h-8">
                  {timelineMonths.map((month, index) => (
                    <div
                      key={index}
                      className="absolute text-center font-bold text-gray-700 text-sm"
                      style={{
                        left: `${month.startPx}px`,
                        width: `${month.endPx - month.startPx + calculatedDaysPerPixel}px`, // Adjust width to cover all days
                      }}
                    >
                      {month.name}
                    </div>
                  ))}
                </div>
                {/* Day Numbers */}
                <div className="relative h-8">
                  <div className="absolute inset-y-0 left-0 right-0 h-1 bg-gray-200 z-0 top-1/2 -translate-y-1/2"></div>
                  {timelineMonths.map((month) => (
                    <React.Fragment key={month.name}>
                      {month.days.map((day, dayIndex) => (
                        <div
                          key={`${month.name}-${day.dayOfMonth}`}
                          className="absolute text-center text-xs text-gray-500"
                          style={{ left: `${day.position}px` }}
                        >
                          {day.dayOfMonth}
                          <div className="absolute top-1/2 left-1/2 -translate-x-1/2 h-10 w-px bg-gray-300"></div>
                        </div>
                      ))}
                    </React.Fragment>
                  ))}
                </div>
              </div>

              {/* Linha da data atual */}
              {todayLinePosition > 0 && (
                <div
                    className="absolute top-0 bottom-0 z-50 pointer-events-none"
                    style={{ left: `${todayLinePosition + projectLabelWidth}px` }}
                >
                    {/* Linha ajustada para começar no topo do círculo e esticar */}
                    <div className="absolute w-0.5 bg-red-500" style={{ top: '-30px', height: 'calc(100% + 30px)', left: '-1px' }}></div>
                    {/* Círculo ajustado para alinhar com o centro da linha e tocar nela */}
                    <div className="absolute" style={{ top: '-30px', left: '-8px' }}>
                        <div className="w-4 h-4 rounded-full bg-red-500"></div>
                    </div>
                </div>
              )}

              {/* Project rendering */}
              {projects.map(project => {
                const { left, width, startDate, endDate } = projectPositions[project.id] || {};
                if (!left) return null;
                const progressColor = getProjectColor(project.progress);
                
                return (
                  <div key={project.id} className="flex items-center mb-6 relative z-20"> {/* Adicionado z-20 para garantir que os projetos fiquem acima do fundo */}
                    <div className="w-16 flex-shrink-0 text-sm font-semibold text-gray-700" style={{ width: `${projectLabelWidth}px` }}>{project.name}</div>
                    <div className="relative h-16" style={{ width: `${calculatedTimelineWidth}px` }}>
                      <div
                        className={`absolute top-1/2 -translate-y-1/2 ${progressColor} h-14 rounded-md flex items-center text-sm text-white font-semibold shadow cursor-pointer transition-all duration-300 hover:scale-105`}
                        style={{ left: `${left}px`, width: `${width}px` }}
                        onClick={() => handleEditProject(project.id)}
                        title={`${project.name} (${formatDate(startDate)} a ${formatDate(endDate)}) - Duração: ${project.duration} dias úteis`}
                      >
                        <div className="flex-1 text-center font-bold">{project.progress}%</div>
                      </div>
                    </div>
                  </div>
                );
              })}
            </div>

            {/* Project editing modal */}
            {editingProject && (
              <div className="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4">
                <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
                  <h2 className="text-lg font-bold mb-4">Editar Progresso: {editingProject.name}</h2>
                  <form onSubmit={handleSaveEdit}>
                    <div className="mb-4">
                      <label htmlFor="progress-input" className="block text-sm font-medium text-gray-700">Progresso (%)</label>
                      <input
                        id="progress-input"
                        type="number"
                        value={formState.progress}
                        onChange={(e) => setFormState({ ...formState, progress: e.target.value })}
                        className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50"
                        min="0"
                        max="100"
                      />
                    </div>
                    <div className="flex justify-end space-x-2">
                      <button
                        type="button"
                        className="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300 transition-colors"
                        onClick={() => setEditingProject(null)}
                      >
                        Cancelar
                      </button>
                      <button
                        type="submit"
                        className="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors"
                      >
                        Salvar
                      </button>
                    </div>
                  </form>
                </div>
              </div>
            )}
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(React.createElement(App));
  </script>
</body>
</html>

